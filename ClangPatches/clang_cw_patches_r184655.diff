Index: include/clang/Basic/Attr.td
===================================================================
--- include/clang/Basic/Attr.td	(revision 184655)
+++ include/clang/Basic/Attr.td	(working copy)
@@ -144,6 +144,12 @@
 // Attributes begin here
 //
 
+def MoveVTable : InheritableAttr {
+  let Spellings = [GNU<"move_vtable">, CXX11<"cw", "move_vtable">];
+  let Args = [IntArgument<"NewOffset">];
+  let Subjects = [Record];
+}
+
 def AddressSpace : Attr {
   let Spellings = [GNU<"address_space">];
   let Args = [IntArgument<"AddressSpace">];
Index: lib/AST/ItaniumCXXABI.cpp
===================================================================
--- lib/AST/ItaniumCXXABI.cpp	(revision 184655)
+++ lib/AST/ItaniumCXXABI.cpp	(working copy)
@@ -39,8 +39,10 @@
     TargetInfo::IntType PtrDiff = Target.getPtrDiffType(0);
     uint64_t Width = Target.getTypeWidth(PtrDiff);
     unsigned Align = Target.getTypeAlign(PtrDiff);
+    // Treeki's CW/PPC mod:
+    //   Added an extra field.
     if (MPT->getPointeeType()->isFunctionType())
-      Width = 2 * Width;
+      Width = 3 * Width;
     return std::make_pair(Width, Align);
   }
 
Index: lib/AST/RecordLayoutBuilder.cpp
===================================================================
--- lib/AST/RecordLayoutBuilder.cpp	(revision 184655)
+++ lib/AST/RecordLayoutBuilder.cpp	(working copy)
@@ -545,6 +545,11 @@
 
   EmptySubobjectMap *EmptySubobjects;
 
+  // Treeki's CW/PPC mod:
+  //   Added some bits.
+  CharUnits RVTMovedOffset;
+  const CXXRecordDecl *SaveCXXRD;
+
   /// Size - The current size of the record layout.
   uint64_t Size;
 
@@ -653,7 +658,9 @@
       PrimaryBaseIsVirtual(false),
       HasOwnVFPtr(false),
       VBPtrOffset(CharUnits::fromQuantity(-1)),
-      FirstNearlyEmptyVBase(0) { }
+      FirstNearlyEmptyVBase(0),
+      RVTMovedOffset(CharUnits::fromQuantity(-1)),
+      SaveCXXRD(0) { }
 
   /// Reset this RecordLayoutBuilder to a fresh state, using the given
   /// alignment as the initial alignment.  This is used for the
@@ -779,6 +786,8 @@
   }
   uint64_t getSizeInBits() const { return Size; }
 
+  void TryPlaceVTable();
+
   void setSize(CharUnits NewSize) { Size = Context.toBits(NewSize); }
   void setSize(uint64_t NewSize) { Size = NewSize; }
 
@@ -1009,6 +1018,41 @@
 }
 
 void
+RecordLayoutBuilder::TryPlaceVTable() {
+  // C++ only.
+  if (!SaveCXXRD)
+    return;
+
+  // If the offset is negative, we did it at the start.
+  if (RVTMovedOffset.isNegative())
+    return;
+
+  // If we have a vfptr, we've already done it.
+  if (HasOwnVFPtr)
+    return;
+
+  // ... and we might not even need a vtable at all.
+  if (!needsVFTable(SaveCXXRD))
+    return;
+
+  CharUnits curSize = getSize();
+  if (curSize > RVTMovedOffset) {
+    llvm::errs() << "WTF? We missed the RVTMovedOffset! Size = " << curSize.getQuantity() << "; RVTMovedOffset = " << RVTMovedOffset.getQuantity() << "\n";
+  } else if (curSize == RVTMovedOffset) {
+    llvm::errs() << "VTable placed!!\n";
+
+    CharUnits PtrWidth = 
+    Context.toCharUnitsFromBits(Context.getTargetInfo().getPointerWidth(0));
+    CharUnits PtrAlign = 
+    Context.toCharUnitsFromBits(Context.getTargetInfo().getPointerAlign(0));
+    EnsureVTablePointerAlignment(PtrAlign);
+    HasOwnVFPtr = true;
+    setSize(getSize() + PtrWidth);
+    setDataSize(getSize());
+  }
+}
+
+void
 RecordLayoutBuilder::LayoutNonVirtualBases(const CXXRecordDecl *RD) {
   // Then, determine the primary base class.
   DeterminePrimaryBase(RD);
@@ -1015,6 +1059,7 @@
 
   // Compute base subobject info.
   ComputeBaseSubobjectInfo(RD);
+
   
   // If we have a primary base class, lay it out.
   if (PrimaryBase) {
@@ -1044,15 +1089,19 @@
   // If this class needs a vtable/vf-table and didn't get one from a
   // primary base, add it in now.
   } else if (needsVFTable(RD)) {
-    assert(DataSize == 0 && "Vtable pointer must be at offset zero!");
-    CharUnits PtrWidth = 
+    // Treeki's CW/PPC mod:
+    //   Skip this if we've got a forced location.
+    if (RVTMovedOffset.isNegative()) {
+      assert(DataSize == 0 && "Vtable pointer must be at offset zero!");
+      CharUnits PtrWidth = 
       Context.toCharUnitsFromBits(Context.getTargetInfo().getPointerWidth(0));
-    CharUnits PtrAlign = 
+      CharUnits PtrAlign = 
       Context.toCharUnitsFromBits(Context.getTargetInfo().getPointerAlign(0));
-    EnsureVTablePointerAlignment(PtrAlign);
-    HasOwnVFPtr = true;
-    setSize(getSize() + PtrWidth);
-    setDataSize(getSize());
+      EnsureVTablePointerAlignment(PtrAlign);
+      HasOwnVFPtr = true;
+      setSize(getSize() + PtrWidth);
+      setDataSize(getSize());
+    }
   }
 
   bool HasDirectVirtualBases = false;
@@ -1536,6 +1585,8 @@
       EmptySubobjects->CanPlaceBaseAtOffset(Base, CharUnits::Zero())) {
     setSize(std::max(getSize(), Layout.getSize()));
 
+    TryPlaceVTable();
+
     return CharUnits::Zero();
   }
 
@@ -1579,6 +1630,8 @@
   // Remember max struct/class alignment.
   UpdateAlignment(BaseAlign, UnpackedBaseAlign);
 
+  TryPlaceVTable();
+
   return Offset;
 }
 
@@ -1643,6 +1696,12 @@
 }
 
 void RecordLayoutBuilder::Layout(const CXXRecordDecl *RD) {
+  SaveCXXRD = RD;
+
+  if (RD->hasAttr<MoveVTableAttr>()) {
+    MoveVTableAttr *attr = RD->getAttr<MoveVTableAttr>();
+    RVTMovedOffset = CharUnits::fromQuantity(attr->getNewOffset());
+  }
   InitializeLayout(RD);
 
   // Lay out the vtable and the non-virtual bases.
@@ -1728,106 +1787,14 @@
 void RecordLayoutBuilder::LayoutFields(const RecordDecl *D) {
   // Layout each field, for now, just sequentially, respecting alignment.  In
   // the future, this will need to be tweakable by targets.
-  const FieldDecl *LastFD = 0;
+
+  // Treeki's CW/PPC mod:
+  //   screw ms_struct
+
   ZeroLengthBitfield = 0;
-  unsigned RemainingInAlignment = 0;
   for (RecordDecl::field_iterator Field = D->field_begin(),
        FieldEnd = D->field_end(); Field != FieldEnd; ++Field) {
-    if (IsMsStruct) {
-      FieldDecl *FD = *Field;
-      if (Context.ZeroBitfieldFollowsBitfield(FD, LastFD))
-        ZeroLengthBitfield = FD;
-      // Zero-length bitfields following non-bitfield members are
-      // ignored:
-      else if (Context.ZeroBitfieldFollowsNonBitfield(FD, LastFD))
-        continue;
-      // FIXME. streamline these conditions into a simple one.
-      else if (Context.BitfieldFollowsBitfield(FD, LastFD) ||
-               Context.BitfieldFollowsNonBitfield(FD, LastFD) ||
-               Context.NonBitfieldFollowsBitfield(FD, LastFD)) {
-        // 1) Adjacent bit fields are packed into the same 1-, 2-, or
-        // 4-byte allocation unit if the integral types are the same
-        // size and if the next bit field fits into the current
-        // allocation unit without crossing the boundary imposed by the
-        // common alignment requirements of the bit fields.
-        // 2) Establish a new alignment for a bitfield following
-        // a non-bitfield if size of their types differ.
-        // 3) Establish a new alignment for a non-bitfield following
-        // a bitfield if size of their types differ.
-        std::pair<uint64_t, unsigned> FieldInfo = 
-          Context.getTypeInfo(FD->getType());
-        uint64_t TypeSize = FieldInfo.first;
-        unsigned FieldAlign = FieldInfo.second;
-        // This check is needed for 'long long' in -m32 mode.
-        if (TypeSize > FieldAlign &&
-            (Context.hasSameType(FD->getType(), 
-                                Context.UnsignedLongLongTy) 
-             ||Context.hasSameType(FD->getType(), 
-                                   Context.LongLongTy)))
-          FieldAlign = TypeSize;
-        FieldInfo = Context.getTypeInfo(LastFD->getType());
-        uint64_t TypeSizeLastFD = FieldInfo.first;
-        unsigned FieldAlignLastFD = FieldInfo.second;
-        // This check is needed for 'long long' in -m32 mode.
-        if (TypeSizeLastFD > FieldAlignLastFD &&
-            (Context.hasSameType(LastFD->getType(), 
-                                Context.UnsignedLongLongTy)
-             || Context.hasSameType(LastFD->getType(), 
-                                    Context.LongLongTy)))
-          FieldAlignLastFD = TypeSizeLastFD;
-        
-        if (TypeSizeLastFD != TypeSize) {
-          if (RemainingInAlignment &&
-              LastFD && LastFD->isBitField() &&
-              LastFD->getBitWidthValue(Context)) {
-            // If previous field was a bitfield with some remaining unfilled
-            // bits, pad the field so current field starts on its type boundary.
-            uint64_t FieldOffset = 
-            getDataSizeInBits() - UnfilledBitsInLastByte;
-            uint64_t NewSizeInBits = RemainingInAlignment + FieldOffset;
-            setDataSize(llvm::RoundUpToAlignment(NewSizeInBits,
-                                                 Context.getTargetInfo().getCharAlign()));
-            setSize(std::max(getSizeInBits(), getDataSizeInBits()));
-            RemainingInAlignment = 0;
-          }
-          
-          uint64_t UnpaddedFieldOffset = 
-            getDataSizeInBits() - UnfilledBitsInLastByte;
-          FieldAlign = std::max(FieldAlign, FieldAlignLastFD);
-          
-          // The maximum field alignment overrides the aligned attribute.
-          if (!MaxFieldAlignment.isZero()) {
-            unsigned MaxFieldAlignmentInBits = 
-              Context.toBits(MaxFieldAlignment);
-            FieldAlign = std::min(FieldAlign, MaxFieldAlignmentInBits);
-          }
-          
-          uint64_t NewSizeInBits = 
-            llvm::RoundUpToAlignment(UnpaddedFieldOffset, FieldAlign);
-          setDataSize(llvm::RoundUpToAlignment(NewSizeInBits,
-                                               Context.getTargetInfo().getCharAlign()));
-          UnfilledBitsInLastByte = getDataSizeInBits() - NewSizeInBits;
-          setSize(std::max(getSizeInBits(), getDataSizeInBits()));
-        }
-        if (FD->isBitField()) {
-          uint64_t FieldSize = FD->getBitWidthValue(Context);
-          assert (FieldSize > 0 && "LayoutFields - ms_struct layout");
-          if (RemainingInAlignment < FieldSize)
-            RemainingInAlignment = TypeSize - FieldSize;
-          else
-            RemainingInAlignment -= FieldSize;
-        }
-      }
-      else if (FD->isBitField()) {
-        uint64_t FieldSize = FD->getBitWidthValue(Context);
-        std::pair<uint64_t, unsigned> FieldInfo = 
-          Context.getTypeInfo(FD->getType());
-        uint64_t TypeSize = FieldInfo.first;
-        RemainingInAlignment = TypeSize - FieldSize;
-      }
-      LastFD = FD;
-    }
-    else if (!Context.getTargetInfo().useBitFieldTypeAlignment() &&
+    if (!Context.getTargetInfo().useBitFieldTypeAlignment() &&
              Context.getTargetInfo().useZeroLengthBitfieldAlignment()) {             
       if (Field->isBitField() && Field->getBitWidthValue(Context) == 0)
         ZeroLengthBitfield = *Field;
@@ -1834,17 +1801,6 @@
     }
     LayoutField(*Field);
   }
-  if (IsMsStruct && RemainingInAlignment &&
-      LastFD && LastFD->isBitField() && LastFD->getBitWidthValue(Context)) {
-    // If we ended a bitfield before the full length of the type then
-    // pad the struct out to the full length of the last type.
-    uint64_t FieldOffset = 
-      getDataSizeInBits() - UnfilledBitsInLastByte;
-    uint64_t NewSizeInBits = RemainingInAlignment + FieldOffset;
-    setDataSize(llvm::RoundUpToAlignment(NewSizeInBits,
-                                         Context.getTargetInfo().getCharAlign()));
-    setSize(std::max(getSizeInBits(), getDataSizeInBits()));
-  }
 }
 
 void RecordLayoutBuilder::LayoutWideBitField(uint64_t FieldSize,
@@ -2171,6 +2127,8 @@
 
   // Remember max struct/class alignment.
   UpdateAlignment(FieldAlign, UnpackedFieldAlign);
+
+  TryPlaceVTable();
 }
 
 void RecordLayoutBuilder::FinishLayout(const NamedDecl *D) {
Index: lib/AST/VTableBuilder.cpp
===================================================================
--- lib/AST/VTableBuilder.cpp	(revision 184655)
+++ lib/AST/VTableBuilder.cpp	(working copy)
@@ -1141,10 +1141,8 @@
     // Add it.
     VTableThunks[VTableIndex].This = ThisAdjustment;
 
-    if (isa<CXXDestructorDecl>(MD)) {
-      // Add an adjustment for the deleting destructor as well.
-      VTableThunks[VTableIndex + 1].This = ThisAdjustment;
-    }
+    // Treeki's CW/PPC mod:
+    //   No extra deleting dtor.
   }
 
   /// Clear the method info map.
@@ -1311,14 +1309,9 @@
            "Destructor can't have return adjustment!");
 
     // FIXME: Should probably add a layer of abstraction for vtable generation.
-    if (!isMicrosoftABI()) {
-      // Add both the complete destructor and the deleting destructor.
-      Components.push_back(VTableComponent::MakeCompleteDtor(DD));
-      Components.push_back(VTableComponent::MakeDeletingDtor(DD));
-    } else {
-      // Add the scalar deleting destructor.
-      Components.push_back(VTableComponent::MakeDeletingDtor(DD));
-    }
+    // Treeki's CW/PPC mod:
+    //   Complete dtor only.
+    Components.push_back(VTableComponent::MakeCompleteDtor(DD));
   } else {
     // Add the return adjustment if necessary.
     if (!ReturnAdjustment.isEmpty())
@@ -1687,7 +1680,10 @@
     // breaks the vftable layout. Just skip RTTI for now, can't mangle anyway.
   }
 
-  uint64_t AddressPoint = Components.size();
+  // Treeki's CW/PPC mod:
+  //   Subtract 2 from the AddressPoint because CW expects there to be
+  //   two bits of padding there.
+  uint64_t AddressPoint = Components.size() - 2;
 
   // Now go through all virtual member functions and add them.
   PrimaryBasesSetVectorTy PrimaryBases;
@@ -1704,15 +1700,10 @@
       const MethodInfo &MI = I->second;
       if (const CXXDestructorDecl *DD = dyn_cast<CXXDestructorDecl>(MD)) {
         // FIXME: Should probably add a layer of abstraction for vtable generation.
-        if (!isMicrosoftABI()) {
-          MethodVTableIndices[GlobalDecl(DD, Dtor_Complete)]
-              = MI.VTableIndex - AddressPoint;
-          MethodVTableIndices[GlobalDecl(DD, Dtor_Deleting)]
-              = MI.VTableIndex + 1 - AddressPoint;
-        } else {
-          MethodVTableIndices[GlobalDecl(DD, Dtor_Deleting)]
-              = MI.VTableIndex - AddressPoint;
-        }
+        // Treeki's CW/PPC mod:
+        //   Complete dtor only.
+        MethodVTableIndices[GlobalDecl(DD, Dtor_Complete)]
+            = MI.VTableIndex - AddressPoint;
       } else {
         MethodVTableIndices[MD] = MI.VTableIndex - AddressPoint;
       }
@@ -2212,18 +2203,11 @@
                                   MD);
 
     if (const CXXDestructorDecl *DD = dyn_cast<CXXDestructorDecl>(MD)) {
-      // FIXME: Should add a layer of abstraction for vtable generation.
-      if (!isMicrosoftABI()) {
-        GlobalDecl GD(DD, Dtor_Complete);
-        assert(MethodVTableIndices.count(GD));
-        uint64_t VTableIndex = MethodVTableIndices[GD];
-        IndicesMap[VTableIndex] = MethodName + " [complete]";
-        IndicesMap[VTableIndex + 1] = MethodName + " [deleting]";
-      } else {
-        GlobalDecl GD(DD, Dtor_Deleting);
-        assert(MethodVTableIndices.count(GD));
-        IndicesMap[MethodVTableIndices[GD]] = MethodName + " [scalar deleting]";
-      }
+      // Treeki's CW/PPC mod:
+      //   Complete dtor only.
+      GlobalDecl GD(DD, Dtor_Complete);
+      assert(MethodVTableIndices.count(GD));
+      IndicesMap[MethodVTableIndices[GD]] = MethodName + " [complete]";
     } else {
       assert(MethodVTableIndices.count(MD));
       IndicesMap[MethodVTableIndices[MD]] = MethodName;
Index: lib/CodeGen/CGCXX.cpp
===================================================================
--- lib/CodeGen/CGCXX.cpp	(revision 184655)
+++ lib/CodeGen/CGCXX.cpp	(working copy)
@@ -173,29 +173,18 @@
 }
 
 void CodeGenModule::EmitCXXConstructors(const CXXConstructorDecl *D) {
+  // Treeki's CW/PPC mod:
+  //   ONLY make a Complete ctor.
+
   // The constructor used for constructing this as a complete class;
   // constucts the virtual bases, then calls the base constructor.
-  if (!D->getParent()->isAbstract()) {
-    // We don't need to emit the complete ctor if the class is abstract.
-    EmitGlobal(GlobalDecl(D, Ctor_Complete));
-  }
-
-  // The constructor used for constructing this as a base class;
-  // ignores virtual bases.
-  if (getTarget().getCXXABI().hasConstructorVariants())
-    EmitGlobal(GlobalDecl(D, Ctor_Base));
+  EmitGlobal(GlobalDecl(D, Ctor_Complete));
 }
 
 void CodeGenModule::EmitCXXConstructor(const CXXConstructorDecl *ctor,
                                        CXXCtorType ctorType) {
-  // The complete constructor is equivalent to the base constructor
-  // for classes with no virtual bases.  Try to emit it as an alias.
-  if (getTarget().getCXXABI().hasConstructorVariants() &&
-      ctorType == Ctor_Complete &&
-      !ctor->getParent()->getNumVBases() &&
-      !TryEmitDefinitionAsAlias(GlobalDecl(ctor, Ctor_Complete),
-                                GlobalDecl(ctor, Ctor_Base)))
-    return;
+  // Treeki's CW/PPC mod:
+  //   Don't alias to Base ctors. We don't have that!
 
   const CGFunctionInfo &fnInfo =
     getTypes().arrangeCXXConstructorDeclaration(ctor, ctorType);
@@ -229,38 +218,19 @@
 }
 
 void CodeGenModule::EmitCXXDestructors(const CXXDestructorDecl *D) {
-  // The destructor in a virtual table is always a 'deleting'
-  // destructor, which calls the complete destructor and then uses the
-  // appropriate operator delete.
-  if (D->isVirtual())
-    EmitGlobal(GlobalDecl(D, Dtor_Deleting));
+  // Treeki's CW/PPC mod:
+  //   ONLY make a Complete dtor.
 
   // The destructor used for destructing this as a most-derived class;
   // call the base destructor and then destructs any virtual bases.
   EmitGlobal(GlobalDecl(D, Dtor_Complete));
-
-  // The destructor used for destructing this as a base class; ignores
-  // virtual bases.
-  EmitGlobal(GlobalDecl(D, Dtor_Base));
 }
 
 void CodeGenModule::EmitCXXDestructor(const CXXDestructorDecl *dtor,
                                       CXXDtorType dtorType) {
-  // The complete destructor is equivalent to the base destructor for
-  // classes with no virtual bases, so try to emit it as an alias.
-  if (dtorType == Dtor_Complete &&
-      !dtor->getParent()->getNumVBases() &&
-      !TryEmitDefinitionAsAlias(GlobalDecl(dtor, Dtor_Complete),
-                                GlobalDecl(dtor, Dtor_Base)))
-    return;
+  // Treeki's CW/PPC mod:
+  //   Don't alias to Base dtors. We don't have that!
 
-  // The base destructor is equivalent to the base destructor of its
-  // base class if there is exactly one non-virtual base class with a
-  // non-trivial destructor, there are no fields with a non-trivial
-  // destructor, and the body of the destructor is trivial.
-  if (dtorType == Dtor_Base && !TryEmitBaseDestructorAsAlias(dtor))
-    return;
-
   const CGFunctionInfo &fnInfo =
     getTypes().arrangeCXXDestructor(dtor, dtorType);
 
@@ -291,11 +261,12 @@
                                                       /*ForVTable=*/false));
 }
 
-static llvm::Value *BuildVirtualCall(CodeGenFunction &CGF, uint64_t VTableIndex, 
+static llvm::Value *BuildVirtualCall(const CXXMethodDecl *MD,
+                                     CodeGenFunction &CGF, uint64_t VTableIndex, 
                                      llvm::Value *This, llvm::Type *Ty) {
   Ty = Ty->getPointerTo()->getPointerTo();
   
-  llvm::Value *VTable = CGF.GetVTablePtr(This, Ty);
+  llvm::Value *VTable = CGF.GetVTablePtr(MD->getParent()->getCanonicalDecl(), This, Ty);
   llvm::Value *VFuncPtr = 
     CGF.Builder.CreateConstInBoundsGEP1_64(VTable, VTableIndex, "vfn");
   return CGF.Builder.CreateLoad(VFuncPtr);
@@ -307,7 +278,7 @@
   MD = MD->getCanonicalDecl();
   uint64_t VTableIndex = CGM.getVTableContext().getMethodVTableIndex(MD);
   
-  return ::BuildVirtualCall(*this, VTableIndex, This, Ty);
+  return ::BuildVirtualCall(MD, *this, VTableIndex, This, Ty);
 }
 
 /// BuildVirtualCall - This routine is to support gcc's kext ABI making
@@ -388,6 +359,6 @@
   uint64_t VTableIndex = 
     CGM.getVTableContext().getMethodVTableIndex(GlobalDecl(DD, Type));
 
-  return ::BuildVirtualCall(*this, VTableIndex, This, Ty);
+  return ::BuildVirtualCall(DD, *this, VTableIndex, This, Ty);
 }
 
Index: lib/CodeGen/CGClass.cpp
===================================================================
--- lib/CodeGen/CGClass.cpp	(revision 184655)
+++ lib/CodeGen/CGClass.cpp	(working copy)
@@ -349,7 +349,11 @@
         CGF.GetAddressOfDirectBaseInCompleteClass(CGF.LoadCXXThis(),
                                                   DerivedClass, BaseClass,
                                                   BaseIsVirtual);
-      CGF.EmitCXXDestructorCall(D, Dtor_Base, BaseIsVirtual,
+
+      // Treeki's CW/PPC mod:
+      //   Don't delegate to the Base dtor. We're using Complete
+      //   as the canonical dtor.
+      CGF.EmitCXXDestructorCall(D, Dtor_Complete, BaseIsVirtual,
                                 /*Delegating=*/false, Addr);
     }
   };
@@ -697,15 +701,19 @@
   const CXXConstructorDecl *Ctor = cast<CXXConstructorDecl>(CurGD.getDecl());
   CXXCtorType CtorType = CurGD.getCtorType();
 
+  // Treeki's CW/PPC mod:
+  //   Don't delegate to base. We're using the complete ctor as
+  //   the canonical one.
+
   // Before we go any further, try the complete->base constructor
   // delegation optimization.
-  if (CtorType == Ctor_Complete && IsConstructorDelegationValid(Ctor) &&
-      CGM.getTarget().getCXXABI().hasConstructorVariants()) {
-    if (CGDebugInfo *DI = getDebugInfo()) 
-      DI->EmitLocation(Builder, Ctor->getLocEnd());
-    EmitDelegateCXXConstructorCall(Ctor, Ctor_Base, Args);
-    return;
-  }
+  // if (CtorType == Ctor_Complete && IsConstructorDelegationValid(Ctor) &&
+  //     CGM.getTarget().getCXXABI().hasConstructorVariants()) {
+  //   if (CGDebugInfo *DI = getDebugInfo()) 
+  //     DI->EmitLocation(Builder, Ctor->getLocEnd());
+  //   EmitDelegateCXXConstructorCall(Ctor, Ctor_Base, Args);
+  //   return;
+  // }
 
   Stmt *Body = Ctor->getBody();
 
@@ -1243,14 +1251,12 @@
   // outside of the function-try-block, which means it's always
   // possible to delegate the destructor body to the complete
   // destructor.  Do so.
-  if (DtorType == Dtor_Deleting) {
-    EnterDtorCleanups(Dtor, Dtor_Deleting);
-    EmitCXXDestructorCall(Dtor, Dtor_Complete, /*ForVirtualBase=*/false,
-                          /*Delegating=*/false, LoadCXXThis());
-    PopCleanupBlock();
-    return;
-  }
 
+  // Treeki's CW/PPC mod:
+  //   ALWAYS include delete code...!
+
+  EnterDtorCleanups(Dtor, Dtor_Deleting);
+
   Stmt *Body = Dtor->getBody();
 
   // If the body is a function-try-block, enter the try before
@@ -1273,13 +1279,9 @@
     // Enter the cleanup scopes for virtual bases.
     EnterDtorCleanups(Dtor, Dtor_Complete);
 
-    if (!isTryBody &&
-        CGM.getTarget().getCXXABI().hasDestructorVariants()) {
-      EmitCXXDestructorCall(Dtor, Dtor_Base, /*ForVirtualBase=*/false,
-                            /*Delegating=*/false, LoadCXXThis());
-      break;
-    }
-    // Fallthrough: act like we're in the base variant.
+    // Treeki's CW/PPC mod:
+    //   Don't delegate to the Base dtor. In our case, we're using
+    //   Complete as the "canonical" dtor, and Base is never generated.
       
   case Dtor_Base:
     // Enter the cleanup scopes for fields and non-virtual bases.
@@ -1354,8 +1356,10 @@
     void Emit(CodeGenFunction &CGF, Flags flags) {
       llvm::BasicBlock *callDeleteBB = CGF.createBasicBlock("dtor.call_delete");
       llvm::BasicBlock *continueBB = CGF.createBasicBlock("dtor.continue");
+      // Treeki's CW/PPC mod:
+      //   Change IsNull to IsLe zero.
       llvm::Value *ShouldCallDelete
-        = CGF.Builder.CreateIsNull(ShouldDeleteCondition);
+        = CGF.Builder.CreateICmpSLE(ShouldDeleteCondition, llvm::ConstantInt::get(ShouldDeleteCondition->getType(), 0));
       CGF.Builder.CreateCondBr(ShouldCallDelete, continueBB, callDeleteBB);
 
       CGF.EmitBlock(callDeleteBB);
@@ -1823,9 +1827,14 @@
   if (!Callee)
     Callee = CGM.GetAddrOfCXXDestructor(DD, Type);
   
+  // Treeki's CW/PPC mod:
+  //   Removed VTT. Added the implicit dtor param.
+  int iParamValue = (Type == Dtor_Deleting) ? 1 : -1;
+  llvm::Value *ImplicitParam = llvm::ConstantInt::get(CGM.IntTy, iParamValue);
+
   // FIXME: Provide a source location here.
   EmitCXXMemberCall(DD, SourceLocation(), Callee, ReturnValueSlot(), This,
-                    VTT, getContext().getPointerType(getContext().VoidPtrTy),
+                    ImplicitParam, getContext().IntTy,
                     0, 0);
   if (CGM.getCXXABI().HasThisReturn(CurGD) &&
       CGM.getCXXABI().HasThisReturn(GlobalDecl(DD, Type)))
@@ -1910,6 +1919,43 @@
   } else {
     // We can just use the base offset in the complete class.
     NonVirtualOffset = Base.getBaseOffset();
+    // Treeki's CW/PPC mod: [RVT, TODO]
+    //   Move vtable pointer.
+
+    // We need to find out which base class defines the vtable, so we
+    //   can know if it gets moved or not. Fun, right...?
+
+    // TODO: This would be much nicer if I stored the info into
+    //   ASTRecordLayout, and pulled it from there for here.
+    //   I can get one with getContext().getASTRecordLayout()
+
+    llvm::errs() << "Loading vtable ptr for " << RD->getName() << " from\n";
+
+    const CXXRecordDecl *checkRD = RD;
+    while (checkRD) {
+      if (checkRD->hasAttr<MoveVTableAttr>()) {
+        int v = checkRD->getAttr<MoveVTableAttr>()->getNewOffset();
+        NonVirtualOffset += CharUnits::fromQuantity(v);
+        llvm::errs() << "Found: " << v << "\n";
+        break;
+      }
+
+      // Not dynamic.
+      if (!checkRD->isDynamicClass())
+        break;
+
+      // No bases.
+      if (checkRD->getNumBases() == 0)
+        break;
+
+      // Too many bases.
+      if (checkRD->getNumBases() > 1)
+        break;
+
+      // aaaaaaa
+      checkRD =
+        cast<CXXRecordDecl>(checkRD->bases_begin()->getType()->getAs<RecordType>()->getDecl());
+    }
   }
   
   // Apply the offsets.
@@ -2009,10 +2055,68 @@
                                            llvm::Type *Ty) {
   llvm::Value *VTablePtrSrc = Builder.CreateBitCast(This, Ty->getPointerTo());
   llvm::Instruction *VTable = Builder.CreateLoad(VTablePtrSrc, "vtable");
+
   CGM.DecorateInstruction(VTable, CGM.getTBAAInfoForVTablePtr());
   return VTable;
 }
 
+llvm::Value *CodeGenFunction::GetVTablePtr(const CXXRecordDecl *WhichDecl,
+                                           llvm::Value *This,
+                                           llvm::Type *Ty) {
+  // Treeki's CW/PPC mod: [RVT, TODO]
+  //   Move vtable pointer.
+
+  // We need to find out which base class defines the vtable, so we
+  //   can know if it gets moved or not. Fun, right...?
+
+  // TODO: This would be much nicer if I stored the info into
+  //   ASTRecordLayout, and pulled it from there for here.
+  //   I can get one with getContext().getASTRecordLayout()
+
+  // llvm::errs() << "Loading vtable ptr for " << WhichDecl->getName() << " from\n";
+
+  CharUnits vtDiff = CharUnits::Zero();
+
+  const CXXRecordDecl *checkRD = WhichDecl;
+  while (checkRD) {
+    if (checkRD->hasAttr<MoveVTableAttr>()) {
+      int v = checkRD->getAttr<MoveVTableAttr>()->getNewOffset();
+      vtDiff = CharUnits::fromQuantity(v);
+      // llvm::errs() << "Found: " << v << "\n";
+      break;
+    }
+
+    // Not dynamic.
+    if (!checkRD->isDynamicClass())
+      break;
+
+    // No bases.
+    if (checkRD->getNumBases() == 0)
+      break;
+
+    // Too many bases.
+    if (checkRD->getNumBases() > 1)
+      break;
+
+    // aaaaaaa
+    checkRD =
+      cast<CXXRecordDecl>(checkRD->bases_begin()->getType()->getAs<RecordType>()->getDecl());
+  }
+
+  if (!vtDiff.isZero()) {
+    llvm::Value *v = llvm::ConstantInt::get(PtrDiffTy,
+                                        vtDiff.getQuantity());
+    This = Builder.CreateBitCast(This, Int8PtrTy);
+    This = Builder.CreateInBoundsGEP(This, v, "add.ptr");
+  }
+
+  llvm::Value *VTablePtrSrc = Builder.CreateBitCast(This, Ty->getPointerTo());
+  llvm::Instruction *VTable = Builder.CreateLoad(VTablePtrSrc, "vtable");
+
+  CGM.DecorateInstruction(VTable, CGM.getTBAAInfoForVTablePtr());
+  return VTable;
+}
+
 static const CXXRecordDecl *getMostDerivedClassDecl(const Expr *Base) {
   const Expr *E = Base;
   
Index: lib/CodeGen/CGExprCXX.cpp
===================================================================
--- lib/CodeGen/CGExprCXX.cpp	(revision 184655)
+++ lib/CodeGen/CGExprCXX.cpp	(working copy)
@@ -510,7 +510,10 @@
       // fall-through
 
      case CXXConstructExpr::CK_NonVirtualBase:
-      Type = Ctor_Base;
+      // Treeki's CW/PPC mod:
+      //   Changed Ctor_Base here to Ctor_Complete.
+      //   Because we're always using Complete.
+      Type = Ctor_Complete;
     }
     
     // Call the constructor.
Index: lib/CodeGen/CGRecordLayoutBuilder.cpp
===================================================================
--- lib/CodeGen/CGRecordLayoutBuilder.cpp	(revision 184655)
+++ lib/CodeGen/CGRecordLayoutBuilder.cpp	(working copy)
@@ -33,6 +33,15 @@
 
 class CGRecordLayoutBuilder {
 public:
+  // Treeki's CW/PPC mod:
+  //   Added some bits.
+  CharUnits RVTMovedOffset;
+  const CXXRecordDecl *SaveCXXRD;
+  const ASTRecordLayout *SaveLayout;
+  bool AddedVTablePointer;
+
+  void TryPlaceVTable();
+
   /// FieldTypes - Holds the LLVM types that the struct is created from.
   /// 
   SmallVector<llvm::Type *, 16> FieldTypes;
@@ -193,10 +202,13 @@
 
 public:
   CGRecordLayoutBuilder(CodeGenTypes &Types)
-    : BaseSubobjectType(0),
+    : AddedVTablePointer(false),
+      BaseSubobjectType(0),
       IsZeroInitializable(true), IsZeroInitializableAsBase(true),
       Packed(false), IsMsStruct(false),
-      Types(Types) { }
+      Types(Types),
+      RVTMovedOffset(CharUnits::fromQuantity(-1)),
+      SaveCXXRD(0) { }
 
   /// Layout - Will layout a RecordDecl.
   void Layout(const RecordDecl *D);
@@ -205,6 +217,13 @@
 }
 
 void CGRecordLayoutBuilder::Layout(const RecordDecl *D) {
+  if ((SaveCXXRD = dyn_cast<CXXRecordDecl>(D))) {
+    if (D->hasAttr<MoveVTableAttr>()) {
+      MoveVTableAttr *attr = D->getAttr<MoveVTableAttr>();
+      RVTMovedOffset = CharUnits::fromQuantity(attr->getNewOffset());
+    }
+  }
+
   Alignment = Types.getContext().getASTRecordLayout(D).getAlignment();
   Packed = D->hasAttr<PackedAttr>();
   
@@ -219,6 +238,7 @@
     return;
 
   // We weren't able to layout the struct. Try again with a packed struct
+  AddedVTablePointer = false;
   Packed = true;
   LastLaidOutBase.invalidate();
   NextFieldOffset = CharUnits::Zero();
@@ -440,6 +460,7 @@
   AppendField(fieldOffsetInBytes, Ty);
 
   LastLaidOutBase.invalidate();
+  TryPlaceVTable();
   return true;
 }
 
@@ -559,6 +580,7 @@
     return false;
 
   AppendField(baseOffset, subobjectType);
+  TryPlaceVTable();
   return true;
 }
 
@@ -651,6 +673,95 @@
   return true;
 }
 
+void
+CGRecordLayoutBuilder::TryPlaceVTable() {
+  // C++ only.
+  if (!SaveCXXRD)
+    return;
+
+  // If the offset is negative, we did it at the start.
+  if (RVTMovedOffset.isNegative())
+    return;
+
+  // If we have a vfptr, we've already done it.
+  if (AddedVTablePointer)
+    return;
+
+  // ... and we might not even need a vtable at all.
+  if (!SaveLayout->hasOwnVFPtr())
+    return;
+
+  CharUnits curSize = NextFieldOffset;
+  if (curSize > RVTMovedOffset) {
+    llvm::errs() << "[CG] WTF? We missed the RVTMovedOffset! Size = " << curSize.getQuantity() << "; RVTMovedOffset = " << RVTMovedOffset.getQuantity() << "\n";
+  } else if (curSize == RVTMovedOffset) {
+    llvm::errs() << "[CG] VTable placed!!\n";
+  } else {
+    // Don't place it yet
+    return;
+  }
+
+  AddedVTablePointer = true;
+
+  llvm::Type *FunctionType =
+  llvm::FunctionType::get(llvm::Type::getInt32Ty(Types.getLLVMContext()),
+                          /*isVarArg=*/true);
+  llvm::Type *VTableTy = FunctionType->getPointerTo()->getPointerTo();
+
+  // if (getTypeAlignment(VTableTy) > Alignment) {
+  //   // FIXME: Should we allow this to happen in Sema?
+  //   assert(!Packed && "Alignment is wrong even with packed struct!");
+  //   return false;
+  // }
+
+
+  // This bit was copy and pasted from LayoutField mercilessly
+  // uint64_t fieldOffset = NextFieldOffset.getQuantity();
+
+  CharUnits fieldOffsetInBytes = NextFieldOffset;
+    // = Types.getContext().toCharUnitsFromBits(fieldOffset);
+
+  // llvm::Type *Ty = Types.ConvertTypeForMem(VTableTy);
+  CharUnits typeAlignment = getTypeAlignment(VTableTy);
+  VTableTy->dump();
+  // llvm::errs() << "Field Offset: " << fieldOffset << "\n";
+  llvm::errs() << "Field Offset in Bytes: " << fieldOffsetInBytes.getQuantity() << "\n";
+  llvm::errs() << "Type Alignment: " << typeAlignment.getQuantity() << "\n";
+
+  // If the type alignment is larger then the struct alignment, we must use
+  // a packed struct.
+  if (typeAlignment > Alignment) {
+    assert(!Packed && "Alignment is wrong even with packed struct!");
+    llvm::errs() << "Failure\n";
+    return;
+  }
+
+  // Round up the field offset to the alignment of the field type.
+  CharUnits alignedNextFieldOffsetInBytes =
+    NextFieldOffset.RoundUpToAlignment(typeAlignment);
+
+  if (fieldOffsetInBytes < alignedNextFieldOffsetInBytes) {
+    // Try to resize the last base field.
+    if (ResizeLastBaseFieldIfNecessary(fieldOffsetInBytes)) {
+      alignedNextFieldOffsetInBytes = 
+        NextFieldOffset.RoundUpToAlignment(typeAlignment);
+    }
+  }
+
+  if (fieldOffsetInBytes < alignedNextFieldOffsetInBytes) {
+    assert(!Packed && "Could not place field even with packed struct!");
+    llvm::errs() << "More failure\n";
+    return;
+  }
+
+  AppendPadding(fieldOffsetInBytes, typeAlignment);
+
+  // Now append the field.
+  AppendField(fieldOffsetInBytes, VTableTy);
+
+  LastLaidOutBase.invalidate();
+}
+
 bool
 CGRecordLayoutBuilder::LayoutNonVirtualBases(const CXXRecordDecl *RD,
                                              const ASTRecordLayout &Layout) {
@@ -668,20 +779,26 @@
 
   // Otherwise, add a vtable / vf-table if the layout says to do so.
   } else if (Layout.hasOwnVFPtr()) {
-    llvm::Type *FunctionType =
+    // Treeki's CW/PPC mod:
+    //   Skip this if we've got a forced location.
+    if (RVTMovedOffset.isNegative()) {
+      AddedVTablePointer = true;
+
+      llvm::Type *FunctionType =
       llvm::FunctionType::get(llvm::Type::getInt32Ty(Types.getLLVMContext()),
                               /*isVarArg=*/true);
-    llvm::Type *VTableTy = FunctionType->getPointerTo();
+      llvm::Type *VTableTy = FunctionType->getPointerTo();
 
-    if (getTypeAlignment(VTableTy) > Alignment) {
-      // FIXME: Should we allow this to happen in Sema?
-      assert(!Packed && "Alignment is wrong even with packed struct!");
-      return false;
+      if (getTypeAlignment(VTableTy) > Alignment) {
+        // FIXME: Should we allow this to happen in Sema?
+        assert(!Packed && "Alignment is wrong even with packed struct!");
+        return false;
+      }
+
+      assert(NextFieldOffset.isZero() &&
+       "VTable pointer must come first!");
+      AppendField(CharUnits::Zero(), VTableTy->getPointerTo());
     }
-
-    assert(NextFieldOffset.isZero() &&
-           "VTable pointer must come first!");
-    AppendField(CharUnits::Zero(), VTableTy->getPointerTo());
   }
 
   // Layout the non-virtual bases.
@@ -757,6 +874,7 @@
   assert(!Alignment.isZero() && "Did not set alignment!");
 
   const ASTRecordLayout &Layout = Types.getContext().getASTRecordLayout(D);
+  SaveLayout = &Layout;
 
   const CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(D);
   if (RD)
Index: lib/CodeGen/CodeGenFunction.h
===================================================================
--- lib/CodeGen/CodeGenFunction.h	(revision 184655)
+++ lib/CodeGen/CodeGenFunction.h	(working copy)
@@ -1201,6 +1201,7 @@
   /// GetVTablePtr - Return the Value of the vtable pointer member pointed
   /// to by This.
   llvm::Value *GetVTablePtr(llvm::Value *This, llvm::Type *Ty);
+  llvm::Value *GetVTablePtr(const CXXRecordDecl *WhichDecl, llvm::Value *This, llvm::Type *Ty);
 
   /// EnterDtorCleanups - Enter the cleanups necessary to complete the
   /// given phase of destruction for a destructor.  The end result
Index: lib/CodeGen/ItaniumCXXABI.cpp
===================================================================
--- lib/CodeGen/ItaniumCXXABI.cpp	(revision 184655)
+++ lib/CodeGen/ItaniumCXXABI.cpp	(working copy)
@@ -41,6 +41,13 @@
   ItaniumCXXABI(CodeGen::CodeGenModule &CGM, bool IsARM = false) :
     CGCXXABI(CGM), IsARM(IsARM) { }
 
+  void ErrorUnsupportedABIWithoutFunction(StringRef S) {
+    DiagnosticsEngine &Diags = CGM.getDiags();
+    unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
+      "cannot yet compile %0 in this ABI");
+    Diags.Report(DiagID) << S;
+  }
+
   bool isReturnTypeIndirect(const CXXRecordDecl *RD) const {
     // Structures with either a non-trivial destructor or a non-trivial
     // copy constructor are always indirect.
@@ -162,6 +169,16 @@
       llvm::Function *InitFunc);
   LValue EmitThreadLocalDeclRefExpr(CodeGenFunction &CGF,
                                     const DeclRefExpr *DRE);
+
+  // Treeki's CW/PPC mod:
+  //   Moved HasThisReturn from ARM. Removed Dtor_Deleting check.
+
+  bool HasThisReturn(GlobalDecl GD) const {
+    const CXXMethodDecl *MD = dyn_cast_or_null<CXXMethodDecl>(GD.getDecl());
+    if (!MD) return false;
+    return (isa<CXXConstructorDecl>(MD) ||
+              isa<CXXDestructorDecl>(MD));
+  }
 };
 
 class ARMCXXABI : public ItaniumCXXABI {
@@ -168,22 +185,6 @@
 public:
   ARMCXXABI(CodeGen::CodeGenModule &CGM) : ItaniumCXXABI(CGM, /*ARM*/ true) {}
 
-  void BuildConstructorSignature(const CXXConstructorDecl *Ctor,
-                                 CXXCtorType T,
-                                 CanQualType &ResTy,
-                                 SmallVectorImpl<CanQualType> &ArgTys);
-
-  void BuildDestructorSignature(const CXXDestructorDecl *Dtor,
-                                CXXDtorType T,
-                                CanQualType &ResTy,
-                                SmallVectorImpl<CanQualType> &ArgTys);
-
-  void BuildInstanceFunctionParams(CodeGenFunction &CGF,
-                                   QualType &ResTy,
-                                   FunctionArgList &Params);
-
-  void EmitInstanceFunctionProlog(CodeGenFunction &CGF);
-
   void EmitReturnFromThunk(CodeGenFunction &CGF, RValue RV, QualType ResTy);
 
   CharUnits getArrayCookieSizeImpl(QualType elementType);
@@ -195,14 +196,8 @@
   llvm::Value *readArrayCookieImpl(CodeGenFunction &CGF, llvm::Value *allocPtr,
                                    CharUnits cookieSize);
 
-  /// \brief Returns true if the given instance method is one of the
-  /// kinds that the ARM ABI says returns 'this'.
-  bool HasThisReturn(GlobalDecl GD) const {
-    const CXXMethodDecl *MD = dyn_cast_or_null<CXXMethodDecl>(GD.getDecl());
-    if (!MD) return false;
-    return ((isa<CXXDestructorDecl>(MD) && GD.getDtorType() != Dtor_Deleting) ||
-            (isa<CXXConstructorDecl>(MD)));
-  }
+  // Treeki's CW/PPC mod:
+  //   Moved HasThisReturn to Itanium.
 };
 }
 
@@ -233,7 +228,9 @@
 ItaniumCXXABI::ConvertMemberPointerType(const MemberPointerType *MPT) {
   if (MPT->isMemberDataPointer())
     return CGM.PtrDiffTy;
-  return llvm::StructType::get(CGM.PtrDiffTy, CGM.PtrDiffTy, NULL);
+  // Treeki's CW/PPC mod:
+  //   Added an extra field.
+  return llvm::StructType::get(CGM.PtrDiffTy, CGM.PtrDiffTy, CGM.PtrDiffTy, NULL);
 }
 
 /// In the Itanium and ARM ABIs, method pointers have the form:
@@ -272,20 +269,25 @@
     CGM.getTypes().GetFunctionType(
       CGM.getTypes().arrangeCXXMethodType(RD, FPT));
 
-  llvm::Constant *ptrdiff_1 = llvm::ConstantInt::get(CGM.PtrDiffTy, 1);
+  // llvm::Constant *ptrdiff_1 = llvm::ConstantInt::get(CGM.PtrDiffTy, 1);
 
   llvm::BasicBlock *FnVirtual = CGF.createBasicBlock("memptr.virtual");
   llvm::BasicBlock *FnNonVirtual = CGF.createBasicBlock("memptr.nonvirtual");
   llvm::BasicBlock *FnEnd = CGF.createBasicBlock("memptr.end");
 
-  // Extract memptr.adj, which is in the second field.
-  llvm::Value *RawAdj = Builder.CreateExtractValue(MemFnPtr, 1, "memptr.adj");
+  // Treeki's CW/PPC mod:
+  //   Totally reworked lots of this to work with CW's PTMFs.
 
-  // Compute the true adjustment.
-  llvm::Value *Adj = RawAdj;
-  if (IsARM)
-    Adj = Builder.CreateAShr(Adj, ptrdiff_1, "memptr.adj.shifted");
+  // CodeWarrior PPC PTMFs:
+  // first = "this" adjustment
+  // second = negative value OR offset within vtable
+  // third = static func ptr OR vtable ptr offset
 
+  // Extract memptr.adj, which is in the first field.
+  llvm::Value *Adj = Builder.CreateExtractValue(MemFnPtr, 0, "memptr.adj");
+  llvm::Value *OffsInVTable = Builder.CreateExtractValue(MemFnPtr, 1, "memptr.vtptroffset");
+  llvm::Value *FnAsInt = Builder.CreateExtractValue(MemFnPtr, 2, "memptr.ptr");
+
   // Apply the adjustment and cast back to the original struct type
   // for consistency.
   llvm::Value *Ptr = Builder.CreateBitCast(This, Builder.getInt8PtrTy());
@@ -292,17 +294,7 @@
   Ptr = Builder.CreateInBoundsGEP(Ptr, Adj);
   This = Builder.CreateBitCast(Ptr, This->getType(), "this.adjusted");
   
-  // Load the function pointer.
-  llvm::Value *FnAsInt = Builder.CreateExtractValue(MemFnPtr, 0, "memptr.ptr");
-  
-  // If the LSB in the function pointer is 1, the function pointer points to
-  // a virtual function.
-  llvm::Value *IsVirtual;
-  if (IsARM)
-    IsVirtual = Builder.CreateAnd(RawAdj, ptrdiff_1);
-  else
-    IsVirtual = Builder.CreateAnd(FnAsInt, ptrdiff_1);
-  IsVirtual = Builder.CreateIsNotNull(IsVirtual, "memptr.isvirtual");
+  llvm::Value *IsVirtual = Builder.CreateICmpSGE(OffsInVTable, llvm::ConstantInt::get(CGM.PtrDiffTy, 0), "memptr.isvirtual");
   Builder.CreateCondBr(IsVirtual, FnVirtual, FnNonVirtual);
 
   // In the virtual path, the adjustment left 'This' pointing to the
@@ -311,13 +303,15 @@
   CGF.EmitBlock(FnVirtual);
 
   // Cast the adjusted this to a pointer to vtable pointer and load.
+  Ptr = Builder.CreateBitCast(This, Builder.getInt8PtrTy());
+  Ptr = Builder.CreateInBoundsGEP(Ptr, FnAsInt);
+
   llvm::Type *VTableTy = Builder.getInt8PtrTy();
-  llvm::Value *VTable = Builder.CreateBitCast(This, VTableTy->getPointerTo());
+  llvm::Value *VTable = Builder.CreateBitCast(Ptr, VTableTy->getPointerTo());
   VTable = Builder.CreateLoad(VTable, "memptr.vtable");
 
   // Apply the offset.
-  llvm::Value *VTableOffset = FnAsInt;
-  if (!IsARM) VTableOffset = Builder.CreateSub(VTableOffset, ptrdiff_1);
+  llvm::Value *VTableOffset = OffsInVTable;
   VTable = Builder.CreateGEP(VTable, VTableOffset);
 
   // Load the virtual function to call.
@@ -427,13 +421,16 @@
   }
 
   // The this-adjustment is left-shifted by 1 on ARM.
-  if (IsARM) {
-    uint64_t offset = cast<llvm::ConstantInt>(adj)->getZExtValue();
-    offset <<= 1;
-    adj = llvm::ConstantInt::get(adj->getType(), offset);
-  }
+  // if (IsARM) {
+  //   uint64_t offset = cast<llvm::ConstantInt>(adj)->getZExtValue();
+  //   offset <<= 1;
+  //   adj = llvm::ConstantInt::get(adj->getType(), offset);
+  // }
 
-  llvm::Value *srcAdj = Builder.CreateExtractValue(src, 1, "src.adj");
+  // Treeki's CW/PPC mod:
+  //   Commented out ARM bit. Changed adj field index 1 to 0.
+
+  llvm::Value *srcAdj = Builder.CreateExtractValue(src, 0, "src.adj");
   llvm::Value *dstAdj;
   if (isDerivedToBase)
     dstAdj = Builder.CreateNSWSub(srcAdj, adj, "adj");
@@ -440,7 +437,7 @@
   else
     dstAdj = Builder.CreateNSWAdd(srcAdj, adj, "adj");
 
-  return Builder.CreateInsertValue(src, dstAdj, 1);
+  return Builder.CreateInsertValue(src, dstAdj, 0);
 }
 
 llvm::Constant *
@@ -475,13 +472,16 @@
   }
 
   // The this-adjustment is left-shifted by 1 on ARM.
-  if (IsARM) {
-    uint64_t offset = cast<llvm::ConstantInt>(adj)->getZExtValue();
-    offset <<= 1;
-    adj = llvm::ConstantInt::get(adj->getType(), offset);
-  }
+  // if (IsARM) {
+  //   uint64_t offset = cast<llvm::ConstantInt>(adj)->getZExtValue();
+  //   offset <<= 1;
+  //   adj = llvm::ConstantInt::get(adj->getType(), offset);
+  // }
 
-  llvm::Constant *srcAdj = llvm::ConstantExpr::getExtractValue(src, 1);
+  // Treeki's CW/PPC mod:
+  //   Commented out ARM bit. Changed adj field index 1 to 0.
+
+  llvm::Constant *srcAdj = llvm::ConstantExpr::getExtractValue(src, 0);
   llvm::Constant *dstAdj;
   if (isDerivedToBase)
     dstAdj = llvm::ConstantExpr::getNSWSub(srcAdj, adj);
@@ -488,7 +488,7 @@
   else
     dstAdj = llvm::ConstantExpr::getNSWAdd(srcAdj, adj);
 
-  return llvm::ConstantExpr::getInsertValue(src, dstAdj, 1);
+  return llvm::ConstantExpr::getInsertValue(src, dstAdj, 0);
 }
 
 llvm::Constant *
@@ -498,8 +498,11 @@
   if (MPT->isMemberDataPointer()) 
     return llvm::ConstantInt::get(CGM.PtrDiffTy, -1ULL, /*isSigned=*/true);
 
+  // Treeki's CW/PPC mod:
+  //   Added extra field.
+
   llvm::Constant *Zero = llvm::ConstantInt::get(CGM.PtrDiffTy, 0);
-  llvm::Constant *Values[2] = { Zero, Zero };
+  llvm::Constant *Values[3] = { Zero, Zero, Zero };
   return llvm::ConstantStruct::getAnon(Values);
 }
 
@@ -523,8 +526,11 @@
 
   CodeGenTypes &Types = CGM.getTypes();
 
+  // Treeki's CW/PPC mod: [RVT]
+  //   Lots of changes. As you may expect.
+
   // Get the function pointer (or index if this is a virtual function).
-  llvm::Constant *MemPtr[2];
+  llvm::Constant *MemPtr[3];
   if (MD->isVirtual()) {
     uint64_t Index = CGM.getVTableContext().getMethodVTableIndex(MD);
 
@@ -533,25 +539,39 @@
       Context.toCharUnitsFromBits(Context.getTargetInfo().getPointerWidth(0));
     uint64_t VTableOffset = (Index * PointerWidth.getQuantity());
 
-    if (IsARM) {
-      // ARM C++ ABI 3.2.1:
-      //   This ABI specifies that adj contains twice the this
-      //   adjustment, plus 1 if the member function is virtual. The
-      //   least significant bit of adj then makes exactly the same
-      //   discrimination as the least significant bit of ptr does for
-      //   Itanium.
-      MemPtr[0] = llvm::ConstantInt::get(CGM.PtrDiffTy, VTableOffset);
-      MemPtr[1] = llvm::ConstantInt::get(CGM.PtrDiffTy,
-                                         2 * ThisAdjustment.getQuantity() + 1);
-    } else {
-      // Itanium C++ ABI 2.3:
-      //   For a virtual function, [the pointer field] is 1 plus the
-      //   virtual table offset (in bytes) of the function,
-      //   represented as a ptrdiff_t.
-      MemPtr[0] = llvm::ConstantInt::get(CGM.PtrDiffTy, VTableOffset + 1);
-      MemPtr[1] = llvm::ConstantInt::get(CGM.PtrDiffTy,
-                                         ThisAdjustment.getQuantity());
+    // Find the VT ptr offset
+    CharUnits vtDiff = CharUnits::Zero();
+
+    const CXXRecordDecl *checkRD = MD->getParent()->getCanonicalDecl();
+    while (checkRD) {
+      if (checkRD->hasAttr<MoveVTableAttr>()) {
+        int v = checkRD->getAttr<MoveVTableAttr>()->getNewOffset();
+        vtDiff = CharUnits::fromQuantity(v);
+        break;
+      }
+
+      // Not dynamic.
+      if (!checkRD->isDynamicClass())
+        break;
+
+      // No bases.
+      if (checkRD->getNumBases() == 0)
+        break;
+
+      // Too many bases.
+      if (checkRD->getNumBases() > 1)
+        break;
+
+      // aaaaaaa
+      checkRD =
+      cast<CXXRecordDecl>(checkRD->bases_begin()->getType()->getAs<RecordType>()->getDecl());
     }
+
+    MemPtr[0] = llvm::ConstantInt::get(CGM.PtrDiffTy,
+                                       ThisAdjustment.getQuantity());
+    MemPtr[1] = llvm::ConstantInt::get(CGM.PtrDiffTy, VTableOffset);
+    MemPtr[2] = llvm::ConstantInt::get(CGM.PtrDiffTy, vtDiff.getQuantity());
+
   } else {
     const FunctionProtoType *FPT = MD->getType()->castAs<FunctionProtoType>();
     llvm::Type *Ty;
@@ -566,9 +586,10 @@
     }
     llvm::Constant *addr = CGM.GetAddrOfFunction(MD, Ty);
 
-    MemPtr[0] = llvm::ConstantExpr::getPtrToInt(addr, CGM.PtrDiffTy);
-    MemPtr[1] = llvm::ConstantInt::get(CGM.PtrDiffTy, (IsARM ? 2 : 1) *
+    MemPtr[0] = llvm::ConstantInt::get(CGM.PtrDiffTy, (IsARM ? 2 : 1) *
                                        ThisAdjustment.getQuantity());
+    MemPtr[1] = llvm::ConstantInt::get(CGM.PtrDiffTy, -1);
+    MemPtr[2] = llvm::ConstantExpr::getPtrToInt(addr, CGM.PtrDiffTy);
   }
   
   return llvm::ConstantStruct::getAnon(MemPtr);
@@ -620,53 +641,26 @@
   if (MPT->isMemberDataPointer())
     return Builder.CreateICmp(Eq, L, R);
 
-  // For member function pointers, the tautologies are more complex.
-  // The Itanium tautology is:
-  //   (L == R) <==> (L.ptr == R.ptr && (L.ptr == 0 || L.adj == R.adj))
-  // The ARM tautology is:
-  //   (L == R) <==> (L.ptr == R.ptr &&
-  //                  (L.adj == R.adj ||
-  //                   (L.ptr == 0 && ((L.adj|R.adj) & 1) == 0)))
-  // The inequality tautologies have exactly the same structure, except
-  // applying De Morgan's laws.
-  
-  llvm::Value *LPtr = Builder.CreateExtractValue(L, 0, "lhs.memptr.ptr");
-  llvm::Value *RPtr = Builder.CreateExtractValue(R, 0, "rhs.memptr.ptr");
+  // Treeki's CW/PPC mod:
+  //   Nuke all this fancy logic for something... simpler.
+  //   CW just compares the three values.
+  //   Now we do the same!
 
-  // This condition tests whether L.ptr == R.ptr.  This must always be
-  // true for equality to hold.
+  llvm::Value *LAdj = Builder.CreateExtractValue(L, 0, "lhs.memptr.adj");
+  llvm::Value *LVOffs = Builder.CreateExtractValue(L, 1, "lhs.memptr.voffs");
+  llvm::Value *LPtr = Builder.CreateExtractValue(L, 2, "lhs.memptr.ptr");
+  llvm::Value *RAdj = Builder.CreateExtractValue(R, 0, "rhs.memptr.adj");
+  llvm::Value *RVOffs = Builder.CreateExtractValue(R, 1, "rhs.memptr.voffs");
+  llvm::Value *RPtr = Builder.CreateExtractValue(R, 2, "rhs.memptr.ptr");
+
   llvm::Value *PtrEq = Builder.CreateICmp(Eq, LPtr, RPtr, "cmp.ptr");
-
-  // This condition, together with the assumption that L.ptr == R.ptr,
-  // tests whether the pointers are both null.  ARM imposes an extra
-  // condition.
-  llvm::Value *Zero = llvm::Constant::getNullValue(LPtr->getType());
-  llvm::Value *EqZero = Builder.CreateICmp(Eq, LPtr, Zero, "cmp.ptr.null");
-
-  // This condition tests whether L.adj == R.adj.  If this isn't
-  // true, the pointers are unequal unless they're both null.
-  llvm::Value *LAdj = Builder.CreateExtractValue(L, 1, "lhs.memptr.adj");
-  llvm::Value *RAdj = Builder.CreateExtractValue(R, 1, "rhs.memptr.adj");
+  llvm::Value *VOffsEq = Builder.CreateICmp(Eq, LVOffs, RVOffs, "cmp.voffs");
   llvm::Value *AdjEq = Builder.CreateICmp(Eq, LAdj, RAdj, "cmp.adj");
 
-  // Null member function pointers on ARM clear the low bit of Adj,
-  // so the zero condition has to check that neither low bit is set.
-  if (IsARM) {
-    llvm::Value *One = llvm::ConstantInt::get(LPtr->getType(), 1);
-
-    // Compute (l.adj | r.adj) & 1 and test it against zero.
-    llvm::Value *OrAdj = Builder.CreateOr(LAdj, RAdj, "or.adj");
-    llvm::Value *OrAdjAnd1 = Builder.CreateAnd(OrAdj, One);
-    llvm::Value *OrAdjAnd1EqZero = Builder.CreateICmp(Eq, OrAdjAnd1, Zero,
-                                                      "cmp.or.adj");
-    EqZero = Builder.CreateBinOp(And, EqZero, OrAdjAnd1EqZero);
-  }
-
   // Tie together all our conditions.
-  llvm::Value *Result = Builder.CreateBinOp(Or, EqZero, AdjEq);
-  Result = Builder.CreateBinOp(And, PtrEq, Result,
+  llvm::Value *TwoTogether = Builder.CreateBinOp(And, VOffsEq, AdjEq);
+  return Builder.CreateBinOp(And, PtrEq, TwoTogether,
                                Inequality ? "memptr.ne" : "memptr.eq");
-  return Result;
 }
 
 llvm::Value *
@@ -683,24 +677,21 @@
     return Builder.CreateICmpNE(MemPtr, NegativeOne, "memptr.tobool");
   }
   
+  // Treeki's CW/PPC mod:
+  //   On CW, a ptmf is not null if any of the fields are non-zero.
   // In Itanium, a member function pointer is not null if 'ptr' is not null.
-  llvm::Value *Ptr = Builder.CreateExtractValue(MemPtr, 0, "memptr.ptr");
 
+  llvm::Value *Adj = Builder.CreateExtractValue(MemPtr, 0, "memptr.adj");
+  llvm::Value *VOffs = Builder.CreateExtractValue(MemPtr, 1, "memptr.voffs");
+  llvm::Value *Ptr = Builder.CreateExtractValue(MemPtr, 2, "memptr.ptr");
+
   llvm::Constant *Zero = llvm::ConstantInt::get(Ptr->getType(), 0);
-  llvm::Value *Result = Builder.CreateICmpNE(Ptr, Zero, "memptr.tobool");
 
-  // On ARM, a member function pointer is also non-null if the low bit of 'adj'
-  // (the virtual bit) is set.
-  if (IsARM) {
-    llvm::Constant *One = llvm::ConstantInt::get(Ptr->getType(), 1);
-    llvm::Value *Adj = Builder.CreateExtractValue(MemPtr, 1, "memptr.adj");
-    llvm::Value *VirtualBit = Builder.CreateAnd(Adj, One, "memptr.virtualbit");
-    llvm::Value *IsVirtual = Builder.CreateICmpNE(VirtualBit, Zero,
-                                                  "memptr.isvirtual");
-    Result = Builder.CreateOr(Result, IsVirtual);
-  }
+  llvm::Value *AdjNotNull = Builder.CreateICmpNE(Adj, Zero, "memptr.adj.notnull");
+  llvm::Value *VOffsNotNull = Builder.CreateICmpNE(VOffs, Zero, "memptr.voffs.notnull");
+  llvm::Value *PtrNotNull = Builder.CreateICmpNE(Ptr, Zero, "memptr.ptr.notnull");
 
-  return Result;
+  return Builder.CreateOr(Builder.CreateOr(AdjNotNull, VOffsNotNull), PtrNotNull);
 }
 
 /// The Itanium ABI requires non-zero initialization only for data
@@ -714,18 +705,10 @@
 llvm::Value *ItaniumCXXABI::adjustToCompleteObject(CodeGenFunction &CGF,
                                                    llvm::Value *ptr,
                                                    QualType type) {
-  // Grab the vtable pointer as an intptr_t*.
-  llvm::Value *vtable = CGF.GetVTablePtr(ptr, CGF.IntPtrTy->getPointerTo());
-
-  // Track back to entry -2 and pull out the offset there.
-  llvm::Value *offsetPtr = 
-    CGF.Builder.CreateConstInBoundsGEP1_64(vtable, -2, "complete-offset.ptr");
-  llvm::LoadInst *offset = CGF.Builder.CreateLoad(offsetPtr);
-  offset->setAlignment(CGF.PointerAlignInBytes);
-
-  // Apply the offset.
-  ptr = CGF.Builder.CreateBitCast(ptr, CGF.Int8PtrTy);
-  return CGF.Builder.CreateInBoundsGEP(ptr, offset);
+  // Treeki's CW/PPC mod:
+  //   We can't implement this when the CW binary has RTTI off. GOODBYE.
+  ErrorUnsupportedABIWithoutFunction("adjustToCompleteObject not supported");
+  return 0;
 }
 
 llvm::Value *
@@ -759,17 +742,15 @@
 
   // 'this' is already there.
 
+  // Treeki's CW/PPC mod:
+  //   Say no to VTTs. Also, add return type.
+
   // Check if we need to add a VTT parameter (which has type void **).
-  if (Type == Ctor_Base && Ctor->getParent()->getNumVBases() != 0)
-    ArgTys.push_back(Context.getPointerType(Context.VoidPtrTy));
-}
+  if (Type == Ctor_Base && Ctor->getParent()->getNumVBases() != 0) {
+    // ArgTys.push_back(Context.getPointerType(Context.VoidPtrTy));
+    ErrorUnsupportedABIWithoutFunction("VTTs not supported");
+  }
 
-/// The ARM ABI does the same as the Itanium ABI, but returns 'this'.
-void ARMCXXABI::BuildConstructorSignature(const CXXConstructorDecl *Ctor,
-                                          CXXCtorType Type,
-                                          CanQualType &ResTy,
-                                SmallVectorImpl<CanQualType> &ArgTys) {
-  ItaniumCXXABI::BuildConstructorSignature(Ctor, Type, ResTy, ArgTys);
   ResTy = ArgTys[0];
 }
 
@@ -783,21 +764,18 @@
 
   // 'this' is already there.
 
+  // Treeki's CW/PPC mod:
+  //   Say no to VTTs.
+  //   Also, add the implicit dtor param. And the return of this.
+
   // Check if we need to add a VTT parameter (which has type void **).
-  if (Type == Dtor_Base && Dtor->getParent()->getNumVBases() != 0)
-    ArgTys.push_back(Context.getPointerType(Context.VoidPtrTy));
-}
+  if (Type == Dtor_Base && Dtor->getParent()->getNumVBases() != 0) {
+    // ArgTys.push_back(Context.getPointerType(Context.VoidPtrTy));
+    ErrorUnsupportedABIWithoutFunction("VTTs not supported");
+  }
 
-/// The ARM ABI does the same as the Itanium ABI, but returns 'this'
-/// for non-deleting destructors.
-void ARMCXXABI::BuildDestructorSignature(const CXXDestructorDecl *Dtor,
-                                         CXXDtorType Type,
-                                         CanQualType &ResTy,
-                                SmallVectorImpl<CanQualType> &ArgTys) {
-  ItaniumCXXABI::BuildDestructorSignature(Dtor, Type, ResTy, ArgTys);
-
-  if (Type != Dtor_Deleting)
-    ResTy = ArgTys[0];
+  ArgTys.push_back(Context.IntTy);
+  ResTy = ArgTys[0];
 }
 
 void ItaniumCXXABI::BuildInstanceFunctionParams(CodeGenFunction &CGF,
@@ -809,25 +787,28 @@
   const CXXMethodDecl *MD = cast<CXXMethodDecl>(CGF.CurGD.getDecl());
   assert(MD->isInstance());
 
+  // Treeki's CW/PPC mod:
+  //   Say no to VTTs.
+  //   Add the implicit param for dtors.
+  //   Also, the return of 'this' if we need it.
+
   // Check if we need a VTT parameter as well.
   if (CodeGenVTables::needsVTTParameter(CGF.CurGD)) {
+    ErrorUnsupportedABI(CGF, "VTTs not supported");
+  }
+
+  if (isa<CXXDestructorDecl>(MD)) {
     ASTContext &Context = getContext();
 
-    // FIXME: avoid the fake decl
-    QualType T = Context.getPointerType(Context.VoidPtrTy);
-    ImplicitParamDecl *VTTDecl
-      = ImplicitParamDecl::Create(Context, 0, MD->getLocation(),
-                                  &Context.Idents.get("vtt"), T);
-    Params.push_back(VTTDecl);
-    getVTTDecl(CGF) = VTTDecl;
+    ImplicitParamDecl *ShouldDelete
+      = ImplicitParamDecl::Create(Context, 0,
+                                  CGF.CurGD.getDecl()->getLocation(),
+                                  &Context.Idents.get("should_call_delete"),
+                                  Context.IntTy);
+    Params.push_back(ShouldDelete);
+    getStructorImplicitParamDecl(CGF) = ShouldDelete;
   }
-}
 
-void ARMCXXABI::BuildInstanceFunctionParams(CodeGenFunction &CGF,
-                                            QualType &ResTy,
-                                            FunctionArgList &Params) {
-  ItaniumCXXABI::BuildInstanceFunctionParams(CGF, ResTy, Params);
-
   // Return 'this' from certain constructors and destructors.
   if (HasThisReturn(CGF.CurGD))
     ResTy = Params[0]->getType();
@@ -837,21 +818,21 @@
   /// Initialize the 'this' slot.
   EmitThisParam(CGF);
 
-  /// Initialize the 'vtt' slot if needed.
-  if (getVTTDecl(CGF)) {
-    getVTTValue(CGF)
-      = CGF.Builder.CreateLoad(CGF.GetAddrOfLocalVar(getVTTDecl(CGF)),
-                               "vtt");
-  }
-}
+  // Treeki's CW/PPC mod:
+  //   Say no to VTTs.
+  //   Also, port over this return from ARM.
 
-void ARMCXXABI::EmitInstanceFunctionProlog(CodeGenFunction &CGF) {
-  ItaniumCXXABI::EmitInstanceFunctionProlog(CGF);
-
   /// Initialize the return slot to 'this' at the start of the
   /// function.
   if (HasThisReturn(CGF.CurGD))
     CGF.Builder.CreateStore(getThisValue(CGF), CGF.ReturnValue);
+
+  if (getStructorImplicitParamDecl(CGF)) {
+    getStructorImplicitParamValue(CGF)
+    = CGF.Builder.CreateLoad(
+      CGF.GetAddrOfLocalVar(getStructorImplicitParamDecl(CGF)),
+      "should_call_delete");
+  }
 }
 
 llvm::Value *ItaniumCXXABI::EmitConstructorCall(CodeGenFunction &CGF,
@@ -861,14 +842,15 @@
                                         llvm::Value *This,
                                         CallExpr::const_arg_iterator ArgBeg,
                                         CallExpr::const_arg_iterator ArgEnd) {
-  llvm::Value *VTT = CGF.GetVTTParameter(GlobalDecl(D, Type), ForVirtualBase,
-                                         Delegating);
-  QualType VTTTy = getContext().getPointerType(getContext().VoidPtrTy);
+
+  // Treeki's CW/PPC mod:
+  //   Say no to VTTs.
+
   llvm::Value *Callee = CGM.GetAddrOfCXXConstructor(D, Type);
 
   // FIXME: Provide a source location here.
   CGF.EmitCXXMemberCall(D, SourceLocation(), Callee, ReturnValueSlot(), This,
-                        VTT, VTTTy, ArgBeg, ArgEnd);
+                        0, QualType(), ArgBeg, ArgEnd);
   return Callee;
 }
 
@@ -881,12 +863,20 @@
   assert(DtorType == Dtor_Deleting || DtorType == Dtor_Complete);
 
   const CGFunctionInfo *FInfo
-    = &CGM.getTypes().arrangeCXXDestructor(Dtor, DtorType);
+    = &CGM.getTypes().arrangeCXXDestructor(Dtor, Dtor_Complete);
   llvm::Type *Ty = CGF.CGM.getTypes().GetFunctionType(*FInfo);
-  llvm::Value *Callee = CGF.BuildVirtualCall(Dtor, DtorType, This, Ty);
+  llvm::Value *Callee = CGF.BuildVirtualCall(Dtor, Dtor_Complete, This, Ty);
 
+  // Treeki's CW/PPC mod:
+  //   Say no to VTTs. Also, add the implicit dtor param.
+  //   I also changed DtorType param to Dtor_Complete in the two above
+  //   methods.
+
+  int iParamValue = (DtorType == Dtor_Deleting) ? 1 : -1;
+  llvm::Value *ImplicitParam = llvm::ConstantInt::get(CGM.IntTy, iParamValue);
+
   return CGF.EmitCXXMemberCall(Dtor, CallLoc, Callee, ReturnValue, This,
-                               /*ImplicitParam=*/0, QualType(), 0, 0);
+                               ImplicitParam, getContext().IntTy, 0, 0);
 }
 
 void ItaniumCXXABI::EmitVirtualInheritanceTables(
@@ -1227,12 +1217,11 @@
                                         llvm::Constant *dtor,
                                         llvm::Constant *addr,
                                         bool TLS) {
-  const char *Name = "__cxa_atexit";
-  if (TLS) {
-    const llvm::Triple &T = CGF.getTarget().getTriple();
-    Name = T.isMacOSX() ?  "_tlv_atexit" : "__cxa_thread_atexit";
-  }
+  // Treeki's CW/PPC mod:
+  //   Lots of changes.
 
+  const char *Name = "__register_global_object";
+
   // We're assuming that the destructor function is something we can
   // reasonably call with the default CC.  Go ahead and cast it to the
   // right prototype.
@@ -1239,10 +1228,10 @@
   llvm::Type *dtorTy =
     llvm::FunctionType::get(CGF.VoidTy, CGF.Int8PtrTy, false)->getPointerTo();
 
-  // extern "C" int __cxa_atexit(void (*f)(void *), void *p, void *d);
-  llvm::Type *paramTys[] = { dtorTy, CGF.Int8PtrTy, CGF.Int8PtrTy };
+  // extern "C" void __register_global_object(void *p, void (*f)(void *), void *block);
+  llvm::Type *paramTys[] = { CGF.Int8PtrTy, dtorTy, CGF.Int8PtrTy };
   llvm::FunctionType *atexitTy =
-    llvm::FunctionType::get(CGF.IntTy, paramTys, false);
+    llvm::FunctionType::get(CGF.VoidTy, paramTys, false);
 
   // Fetch the actual function.
   llvm::Constant *atexit = CGF.CGM.CreateRuntimeFunction(atexitTy, Name);
@@ -1249,14 +1238,21 @@
   if (llvm::Function *fn = dyn_cast<llvm::Function>(atexit))
     fn->setDoesNotThrow();
 
-  // Create a variable that binds the atexit to this shared object.
-  llvm::Constant *handle =
-    CGF.CGM.CreateRuntimeVariable(CGF.Int8Ty, "__dso_handle");
+  // Create the struct CodeWarrior's __register_global_object
+  // requires for each object.
+  llvm::Type *handleType = llvm::StructType::get(CGF.CGM.PtrDiffTy, CGF.CGM.PtrDiffTy, CGF.CGM.PtrDiffTy, NULL);
+  llvm::Constant *handle = CGF.CGM.CreateRuntimeVariable(handleType, "");
+  llvm::GlobalVariable *hGV = cast<llvm::GlobalVariable>(handle);
 
+  hGV->setExternallyInitialized(false);
+  hGV->setAlignment(4);
+  hGV->setLinkage(llvm::GlobalValue::PrivateLinkage);
+  hGV->setInitializer(llvm::ConstantAggregateZero::get(handleType));
+
   llvm::Value *args[] = {
+    llvm::ConstantExpr::getBitCast(addr, CGF.Int8PtrTy),
     llvm::ConstantExpr::getBitCast(dtor, dtorTy),
-    llvm::ConstantExpr::getBitCast(addr, CGF.Int8PtrTy),
-    handle
+    llvm::ConstantExpr::getBitCast(handle, CGF.Int8PtrTy)
   };
   CGF.EmitNounwindRuntimeCall(atexit, args);
 }
@@ -1266,8 +1262,11 @@
                                        const VarDecl &D,
                                        llvm::Constant *dtor,
                                        llvm::Constant *addr) {
+  // Treeki's CW/PPC mod:
+  //   ALWAYS use the CXA atexit function (which I modded)
+
   // Use __cxa_atexit if available.
-  if (CGM.getCodeGenOpts().CXAAtExit)
+  // if (CGM.getCodeGenOpts().CXAAtExit)
     return emitGlobalDtorWithCXAAtExit(CGF, dtor, addr, D.getTLSKind());
 
   if (D.getTLSKind())
Index: lib/Sema/SemaDeclAttr.cpp
===================================================================
--- lib/Sema/SemaDeclAttr.cpp	(revision 184655)
+++ lib/Sema/SemaDeclAttr.cpp	(working copy)
@@ -1976,6 +1976,7 @@
 }
 
 static void handleConstructorAttr(Sema &S, Decl *D, const AttributeList &Attr) {
+  llvm::errs() << "Attr args:" << Attr.getNumArgs() << "\n";
   // check the attribute arguments.
   if (Attr.getNumArgs() > 1) {
     S.Diag(Attr.getLoc(), diag::err_attribute_too_many_arguments) << 1;
@@ -4728,6 +4729,38 @@
                            Attr.getAttributeSpellingListIndex()));
 }
 
+static void handleMoveVtableAttr(Sema &S, Decl *D, const AttributeList &Attr) {
+  // check the attribute arguments.
+  llvm::errs() << "Attr args:" << Attr.getNumArgs() << "\n";
+  if (Attr.getNumArgs() != 1) {
+    S.Diag(Attr.getLoc(), diag::err_attribute_wrong_number_arguments) << 1;
+    return;
+  }
+
+  Expr *E = Attr.getArg(0);
+  llvm::APSInt Idx(32);
+  if (E->isTypeDependent() || E->isValueDependent() ||
+      !E->isIntegerConstantExpr(Idx, S.Context)) {
+    S.Diag(Attr.getLoc(), diag::err_attribute_argument_n_not_int)
+      << "move_vtable" << 1 << E->getSourceRange();
+    return;
+  }
+
+  uint64_t value = Idx.getZExtValue();
+
+  llvm::errs() << "MoveVT : " << value << " for " << cast<NamedDecl>(D)->getName();
+
+  if (!isa<CXXRecordDecl>(D)) {
+    S.Diag(Attr.getLoc(), diag::warn_attribute_wrong_decl_type)
+      << Attr.getName() << ExpectedClass;
+    return;
+  }
+
+  D->addAttr(::new (S.Context)
+             MoveVTableAttr(Attr.getRange(), S.Context, value,
+                            Attr.getAttributeSpellingListIndex()));
+}
+
 //===----------------------------------------------------------------------===//
 // Top Level Sema Entry Points
 //===----------------------------------------------------------------------===//
@@ -4746,6 +4779,7 @@
 static void ProcessInheritableDeclAttr(Sema &S, Scope *scope, Decl *D,
                                        const AttributeList &Attr) {
   switch (Attr.getKind()) {
+  case AttributeList::AT_MoveVTable:  handleMoveVtableAttr(S, D, Attr); break;
   case AttributeList::AT_IBAction:    handleIBAction(S, D, Attr); break;
   case AttributeList::AT_IBOutlet:    handleIBOutlet(S, D, Attr); break;
   case AttributeList::AT_IBOutletCollection:
Index: lib/Sema/SemaDeclCXX.cpp
===================================================================
--- lib/Sema/SemaDeclCXX.cpp	(revision 184655)
+++ lib/Sema/SemaDeclCXX.cpp	(working copy)
@@ -5888,8 +5888,11 @@
 /// on error.
 bool Sema::CheckDestructor(CXXDestructorDecl *Destructor) {
   CXXRecordDecl *RD = Destructor->getParent();
+
+  // Treeki's CW/PPC mod:
+  //   All destructors need delete operators, not just virtual ones.
   
-  if (!Destructor->getOperatorDelete() && Destructor->isVirtual()) {
+  if (!Destructor->getOperatorDelete()) {
     SourceLocation Loc;
     
     if (!Destructor->isImplicit())
